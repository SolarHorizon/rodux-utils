"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[365],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},24347:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(87462),r=(t(67294),t(3905));const i={},o="Organizing your Rodux code",s={unversionedId:"solutions/slices",id:"solutions/slices",title:"Organizing your Rodux code",description:"Many Rodux users struggle with organizing their actions, reducers, and",source:"@site/docs/solutions/slices.md",sourceDirName:"solutions",slug:"/solutions/slices",permalink:"/rodux-utils/docs/solutions/slices",draft:!1,editUrl:"https://github.com/SolarHorizon/rodux-utils/edit/master/docs/solutions/slices.md",tags:[],version:"current",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"Deriving data from State",permalink:"/rodux-utils/docs/solutions/selectors"}},l={},c=[{value:"Slices",id:"slices",level:2},{value:"Customizing generated action handlers",id:"customizing-generated-action-handlers",level:3},{value:"Using <code>extraReducers</code> to add matchers and extra cases",id:"using-extrareducers-to-add-matchers-and-extra-cases",level:3},{value:"Combining slice reducers",id:"combining-slice-reducers",level:2}],d={toc:c},u="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"organizing-your-rodux-code"},"Organizing your Rodux code"),(0,r.kt)("p",null,'Many Rodux users struggle with organizing their actions, reducers, and\nselectors. Patterns like putting all of your actions into one big "Actions"\nfolder can start to make navigating your codebase difficult. Some developers\nhave started to adopt the "ducks" or "slice" pattern, which organizes each\nreducer (and its actions) by which feature they correlate to.'),(0,r.kt)("h2",{id:"slices"},"Slices"),(0,r.kt)("p",null,"Slices help you put all of your related Rodux code in the same spot. RoduxUtils\ncomes with a helper function for quickly generating a slice called\n",(0,r.kt)("a",{parentName:"p",href:"/api/RoduxUtils#createSlice"},(0,r.kt)("inlineCode",{parentName:"a"},"createSlice")),". Let's create a slice with it now."),(0,r.kt)("p",null,"Our slice will contain some data pertaining to the player. We'll track how much\nmoney they have, which items they own, and log any transactions made here. For\nnow, we'll only make our reducer handle incrementing the player's money value."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"createSlice")," uses ",(0,r.kt)("inlineCode",{parentName:"p"},"createReducer")," internally, meaning slice reducers are\nwrapped in an Immut producer.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'return createSlice({\n    name = "playerData",\n    initialState = {\n        money = 0,\n        items = {},\n        transactions = {},\n    },\n    reducers = {\n        moneyIncremented = function(state, action)\n            state.money += action.payload\n        end,\n    }\n})\n')),(0,r.kt)("p",null,"Nice! We've set up our first slice. Right now it's pretty simple. Let's take\na closer look at it. If we were to print the contents of our slice, it'd look\nsomething like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'{\n    name = "playerData",\n    initialState = {\n        money = 0,\n        items = {},\n        transactions = {},\n    },\n    reducer = function,\n    actions = {\n        moneyIncremented = function,\n    },\n}\n')),(0,r.kt)("p",null,"It looks like ",(0,r.kt)("inlineCode",{parentName:"p"},"createSlice")," is reusing our ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"initialState")," inputs,\nbut it's done something with ",(0,r.kt)("inlineCode",{parentName:"p"},"reducers"),". Not only did it create a reducer\nfunction for us, it generated some action creators too! If we plugged this\nreducer into our store, we can use it right away."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local store = Rodux.Store.new(playerData.reducer)\n\n-- give the player $100!\nstore:dispatch(playerData.actions.moneyIncremented(100))\n")),(0,r.kt)("h3",{id:"customizing-generated-action-handlers"},"Customizing generated action handlers"),(0,r.kt)("p",null,"So far so good. We've got a working Rodux store and all of the code for it is\norganized neatly within our slice. Let's add some more functionality. We'll\ncreate the handlers for adding and removing items from the player's inventory.\nOur items are going to be very simple. They'll consist of a numeric ID, a name,\nand a value (in money)."),(0,r.kt)("p",null,"Since creating an item is a little more complicated than incrementing currency,\nwe might want to make our action handler a bit easier to use. Even though our\naction handlers are automatically generated by ",(0,r.kt)("inlineCode",{parentName:"p"},"createSlice"),", we still retain\ncontrol over them."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'return createSlice({\n    name = "playerData",\n    initialState = {\n        money = 0,\n        items = {},\n        transactions = {},\n    },\n    reducers = {\n        moneyIncremented = function(state, action)\n            state.money += action.payload\n        end,\n        itemRemoved = function(state, action)\n            state.items[action.payload] = nil\n        end,\n        itemAdded = {\n            prepare = function(name, value, id)\n                return {\n                    payload = {\n                        name = name,\n                        value = value,\n                        id = id,\n                    },\n                }\n            end,\n            reducer = function(state, action)\n                state.items[action.payload.id] = action.payload\n            end,\n        },\n    },\n})\n')),(0,r.kt)("p",null,"As you can see, our ",(0,r.kt)("inlineCode",{parentName:"p"},"itemAdded")," handler has a bit more going on than the\nothers. That's because we're specifying what our action creator should look\nlike with the ",(0,r.kt)("inlineCode",{parentName:"p"},"prepare")," function. When we want to dispatch ",(0,r.kt)("inlineCode",{parentName:"p"},"itemAdded"),", we can\ndo it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'store:dispatch(itemAdded("Name", 100, 1))\n')),(0,r.kt)("h3",{id:"using-extrareducers-to-add-matchers-and-extra-cases"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"extraReducers")," to add matchers and extra cases"),(0,r.kt)("p",null,"We're almost done. The final piece is logging transactions. We're going to log\nall of the transactions the player has made. There is a problem, though.\nMultiple different action types in our game could be considered transactions.\nPlayers purchasing items, trading items, and selling items are all transactions\nthat we want to be able to support. For simplicity, we'll make some assumptions\nabout what a \"transaction\" actually is in our game."),(0,r.kt)("p",null,'Every transaction can be represented by an action that has a "transactionId"\nproperty inside of the "meta" field of an action. With that in mind, we can\nuse a matcher to handle this for us instead of adding a case for every possible\ntransaction. We\'ll also adjust our existing handlers to support this format.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'return createSlice({\n    name = "playerData",\n    initialState = {\n        money = 0,\n        items = {},\n        transactions = {},\n    },\n    reducers = {\n        moneyIncremented = function(state, action)\n            state.money += action.payload\n        end,\n        itemRemoved = function(state, action)\n            state.items[action.payload] = nil\n        end,\n        itemAdded = {\n            prepare = function(name, value, id, guid)\n                return {\n                    payload = {\n                        name = name,\n                        value = value,\n                        id = id,\n                    },\n                    meta = {\n                        id = guid,\n                    }\n                }\n            end,\n            reducer = function(state, action)\n                state.items[action.payload.id] = action.payload\n            end,\n        },\n    },\n    extraReducers = function(builder)\n        builder\n            :addMatcher(function(action)\n                return action.meta.transactionId ~= nil\n            end, function(state, action)\n                state.transactions[action.meta.transactionId] = action.payload\n            end)\n    end,\n})\n')),(0,r.kt)("p",null,"That was easy! We used ",(0,r.kt)("inlineCode",{parentName:"p"},"extraReducers")," to add a matcher to our slice's reducer\nwith a ",(0,r.kt)("a",{parentName:"p",href:"/api/ReducerBuilder"},(0,r.kt)("inlineCode",{parentName:"a"},"ReducerBuilder"))," Now any time an action is\ndispatched to our store, regardless of whether or not we've got a case reducer\nset up for it."),(0,r.kt)("h2",{id:"combining-slice-reducers"},"Combining slice reducers"),(0,r.kt)("p",null,"If you put all of your slices in the same spot, you can easily require them all\nand combine their reducers before passing them into your store."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local Slices = ReplicatedStorage.Client.Slices\n\nlocal reducers = {}\n\nfor _, module in Slices:GetChildren() do\n    if module:IsA("ModuleScript") then\n        local slice = require(module)\n        reducers[slice.name] = slice.reducer\n    end\nend\n\nlocal reducer = Rodux.combineReducers(reducers)\n\nlocal store = Rodux.Store.new(reducer)\n')))}p.isMDXComponent=!0}}]);