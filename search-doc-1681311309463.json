[{"title":"ReducerBuilder","type":0,"sectionRef":"#","url":"/rodux-utils/api/ReducerBuilder","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#types","content":" "},{"title":"Cases​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#Cases","content":"&lt;/&gt; type Cases = {[string]: Reducer}   "},{"title":"Matchers​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#Matchers","content":"&lt;/&gt; type Matchers = {{ matcher: (Action) → boolean, reducer: Reducer }}  "},{"title":"Functions​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#functions","content":" "},{"title":"addCase​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#addCase","content":"&lt;/&gt; ReducerBuilder:addCase( action: ActionCreator | string,-- The action creator or type name reducer: Reducer ) → () Adds a case reducer. Can only be called before addMatcher and addDefaultCase. Case reducers are reducers that handle one type of action. They are the standard way of writing reducers in Rodux.  "},{"title":"addMatcher​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#addMatcher","content":"&lt;/&gt; ReducerBuilder:addMatcher( matcher: (action: Action) → boolean, reducer: Reducer ) → () Adds a matcher. Cannot be called after addDefaultCase. Matchers can be used to handle actions based on your own custom logic rather than only matching the type.  "},{"title":"addDefaultCase​","type":1,"pageTitle":"ReducerBuilder","url":"/rodux-utils/api/ReducerBuilder#addDefaultCase","content":"&lt;/&gt; ReducerBuilder:addDefaultCase(reducer: Reducer) → () Adds a fallback reducer. This will be invoked if no case reducers or matchers were executed for an action. After adding a default case you cannot modify the reducer anymore, so this should be reserved for the very last part of the chain. "},{"title":"Draft","type":0,"sectionRef":"#","url":"/rodux-utils/api/Draft","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Draft","url":"/rodux-utils/api/Draft#functions","content":" "},{"title":"current​","type":1,"pageTitle":"Draft","url":"/rodux-utils/api/Draft#current","content":"&lt;/&gt; Draft.current(draft: Draft&lt;State&gt;) → State Returns a snapshot of the current state of a draft. This can be expensive! Use it sparingly.  "},{"title":"original​","type":1,"pageTitle":"Draft","url":"/rodux-utils/api/Draft#original","content":"&lt;/&gt; Draft.original(draft: Draft&lt;State&gt;) → State Get the original table from a draft.  "},{"title":"insert​","type":1,"pageTitle":"Draft","url":"/rodux-utils/api/Draft#insert","content":"&lt;/&gt; Draft.insert( draft: Draft&lt;State&gt;, pos: number | V,, value: V? ) → V? Draft-safe replacement for table.insert  "},{"title":"remove​","type":1,"pageTitle":"Draft","url":"/rodux-utils/api/Draft#remove","content":"&lt;/&gt; Draft.remove( draft: Draft&lt;{V}&gt;, pos: number? ) → V? Draft-safe replacement for table.remove "},{"title":"About","type":0,"sectionRef":"#","url":"/rodux-utils/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"About","url":"/rodux-utils/docs/intro#installation","content":""},{"title":"Wally (Recommended)​","type":1,"pageTitle":"About","url":"/rodux-utils/docs/intro#wally-recommended","content":"Rodux Utils is available as a Wally package. wally.toml [dependencies] # make sure to check what the latest version is before adding to your manifest! RoduxUtils = &quot;solarhorizon/rodux-utils@0.3.0&quot;  "},{"title":"Manual​","type":1,"pageTitle":"About","url":"/rodux-utils/docs/intro#manual","content":"Download RoduxUtils.rbxm from the latest releaseand drop it into your project. "},{"title":"RoduxUtils","type":0,"sectionRef":"#","url":"/rodux-utils/api/RoduxUtils","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#types","content":" "},{"title":"MemoizeOptions​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#MemoizeOptions","content":"&lt;/&gt; interface MemoizeOptions { equalityCheck: EqualityFn? resultEqualityCheck: EqualityFn? maxSize: number? } MemoizeOptions can be used to customize the Memoize instance returned from defaultMemoize.  "},{"title":"EqualityFn​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#EqualityFn","content":"&lt;/&gt; type EqualityFn = ( a: any?, b: any? ) → boolean Any type of function that compares two values and returns a boolean.  "},{"title":"ReducerMap​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#ReducerMap","content":"&lt;/&gt; type ReducerMap = {[string]: Reducer | ReducerAndPrepareFn}   "},{"title":"ReducerAndPrepareFn​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#ReducerAndPrepareFn","content":"&lt;/&gt; interface ReducerAndPrepareFn { reducer: Reducer prepare: PrepareFn }  "},{"title":"Functions​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#functions","content":" "},{"title":"defaultMemoize​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#defaultMemoize","content":"&lt;/&gt; RoduxUtils.defaultMemoize( fn: (Args...) → any?,-- The function you want to memoize equalityFnOrOptions: (EqualityFn | MemoizeOptions)? ) → () Memoizes a function. This is the default memoization function forcreateSelector.  "},{"title":"createSelectorCreator​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#createSelectorCreator","content":"&lt;/&gt; RoduxUtils.createSelectorCreator( memoizeFn: MemoizeFn,-- your custom memoization function ...: any?-- any additional arguments to pass to memoizeFn ) → createSelector "},{"title":"Types","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils##","content":""},{"title":"​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#MemoizeFn","content":"type MemoizeFn = ( fn: function, ...any? ) → function  Used to create a custom version of createSelector. local customSelectorCreator = createSelectorCreator( customMemoize, -- function to be used to memoize `fn` option1, -- option1 will be passed as the second argument to `customMemoize` option2 -- option2 will be passed as the third argument to `customMemoize` ) local customSelector = customSelectorCreator( { selectFoo, selectBar, }, resultFunc -- resultFunc will be passed as the first argument to `customMemoize` ) You can find more examples of this in action here.  "},{"title":"createSelector​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#createSelector","content":"&lt;/&gt; RoduxUtils.createSelector( inputSelectors: {Selector}, resultFn: ResultFn, memoizeOptions: MemoizeOptions? | any?,-- options for defaultMemoize, or the first argument to a custom memoization function ...: any?-- additional arguments for a custom memoize function ) → () Create a memoized selector. local selectTotal = createSelector({ function(state) return state.values.value1 end, function(state) return state.values.value2 end, }, function(value1, value2) return value1 + value2 end)   "},{"title":"createReducer​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#createReducer","content":"&lt;/&gt; RoduxUtils.createReducer( initialState: any?, callbackOrHandlers: BuilderCallback | Cases?, matchers: Matchers?,-- not used with BuilderCallback defaultHandler: Reducer?-- not used with BuilderCallback ) → Reducer A simpler way to write a reducer function. Each reducer made withcreateReducer is wrapped in an Immut producer, meaning that you can mutate the state value passed into your handlers. You can add cases for specific action types just like you can with Rodux's createReducer, but you can also add Matcher handlers that will run when a condition that you define is met. Multiple matchers can run for the same action. They are run sequentially in the order you defined them. Examples Callback notation The recommended way to use createReducer is by using a ReducerBuilder with the callback notation. It is more readable than using the map notation. local reducer = createReducer(initialState, function(builder) builder :addCase(&quot;itemAdded&quot;, function(state, action) -- you can mutate `state` here, it's fine! state.items[action.itemId] = action.item end) :addCase(&quot;itemRemoved&quot;, function(state, action) state.items[action.itemId] = nil end) -- run this handler if the action contains a `shouldLog` property :addMatcher(function(action) return action.shouldLog == true end, function(state, action) -- remember: we can't use table.insert on a draft Draft.insert(state.loggedActions, action) end) -- set a fallback for any time an action is dispatched that isn't -- handled by a matcher or case reducer :addDefaultCase(function(state, action) state.unhandledActions += 1 end) end) Map notation You can also use the map notation if you prefer. It should feel similar to the createReducer function that comes with Rodux. You cannot add a default case when using the map notation. This is primarily meant for internal use. local reducer = createReducer(initialState, { -- case reducers itemAdded = function(state, action) state.items[action.itemId] = action.item end, itemRemoved = function(state, action) state.items[action.itemId] = nil end, }, { -- matchers { matcher = function(action) return action.shouldLog == true end, reducer = function(state, action) Draft.insert(state.loggedActions, action) end, } }) -- we can't add a default case with the map notation   "},{"title":"createSlice​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#createSlice","content":"&lt;/&gt; RoduxUtils.createSlice(options: SliceOptions&lt;State&gt;) → Slice&lt;State&gt; "},{"title":"Types","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils##","content":""},{"title":"​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#SliceOptions","content":"interface SliceOptions { name: string initialState: State? reducers: ReducerMap extraReducers: ((builder: ReducerBuilder) → () | Cases)? }  "},{"title":"​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#Slice","content":"interface Slice { name: string reducer: Reducer actions: {[string]: ActionCreator}, initialState: State? }  Automatically generates a reducer and action creators for you. UsescreateAction and createReducer internally, so you're able to customize each generated action creator and use drafts in the reducers. Example Let's create a slice for a todo list. We'll make actions for adding &amp; removing todos from the list, but not for marking a todo as complete. We'll assume our project already has an action for completing tasks, and reuse it in our todo slice. local todoSlice = createSlice({ name = &quot;todo&quot;, initialState = {}, reducers = { -- uses createReducer, so you can mutate state because it's a draft todoRemoved = function(state, action) state[action.payload] = nil end, todoAdded = { reducer = function(state, action) state[action.payload.name] = { done = action.payload.done } end, -- customize the generated action creator prepare = function(name, done) return { payload = { name = name, done = done, } } end, }, }, -- add additional cases that might be relevant to this slice, but have -- an action creator generated elsewhere (like in another slice) extraReducers = function(builder) builder:addCase(&quot;taskCompleted&quot;, function(state, action) local todo = state[action.payload.name] if todo then todo.done = true end end) end, ) Now, let's set up the store and use our slice. local todosSlice = require(ReplicatedStorage.Todos.slice) local tasksSlice = require(ReplicatedStorage.Tasks.slice) local todos = todosSlice.actions local tasks = tasksSlice.actions local reducer = Rodux.combineReducers({ todos = todosSlice.reducer, tasks = tasksSlice.reducer, }) local store = Store.new(reducer) -- add a new todo, mark it as not done store:dispatch(todos.todoAdded(&quot;Buy groceries&quot;, false)) -- complete a task, and mark the todo as done store:dispatch(tasks.taskCompleted(&quot;Buy groceries&quot;) -- remove the todo entirely store:dispatch(todos.todoRemoved(&quot;Buy groceries&quot;))   "},{"title":"createAction​","type":1,"pageTitle":"RoduxUtils","url":"/rodux-utils/api/RoduxUtils#createAction","content":"&lt;/&gt; RoduxUtils.createAction( name: Type, prepareFn: PrepareFn? ) → ActionCreator&lt;Type&gt; Similar to Rodux's makeActionCreator, except any additional data is put inside of a payload property by default. This can be overriden with a custom prepareFn. Examples Using the default structure local todoAdded = createAction(&quot;todoAdded&quot;) print(todoAdded(&quot;Buy groceries&quot;)) -- { type = &quot;todoAdded&quot;, payload = &quot;Buy groceries&quot; } Using a custom structure local playerJoined = createAction(&quot;playerJoined&quot;, function(userId) return { payload = userId, isRoblox = userId == 1, } end) print(playerJoined(1)) -- { type = &quot;playerJoined&quot;, payload = 1, isRoblox = true }  "},{"title":"Dealing with Immutable data","type":0,"sectionRef":"#","url":"/rodux-utils/docs/solutions/immut","content":"","keywords":""},{"title":"Introducing Immut​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#introducing-immut","content":"Immut can address this problem. With Immut, you can write code that looks like it is mutating your immutable data, but actually isn't. Immut uses a proxy that allows you to alter it directly, and only applies your changes to a copy of the original table. Rodux Utils uses Immut in its createReducerfunction to allow you to write reducers in this way. Let's take a look at an example to illustrate the differences between Immut and a more common Immutable data library. In this example, we're using Rodux on the server to keep track of multiple players' inventories. We're going to write a handler for an itemAdded action. It'll add the item stored in action.payload, to the player's inventory. We'll get the UserId of the player from action.meta.userId. Using an Immut &quot;producer&quot;: local inventoryReducer = Rodux.createReducer({ itemAdded = function(state, action) return Immut.produce(state, function(draft) local inventory = draft.players[action.meta.userId] inventory[action.payload.itemId] = action.payload end) end, })  Using an existing Immutable data library: local inventoryReducer = Rodux.createReducer({ itemAdded = function(state, action) return Dictionary.merge(state, { players = Dictionary.merge(state, { [action.meta.userId] = Dictionary.merge(state[action.meta.userId], { [action.payload.itemId] = action.payload }) }) }) end, })  As you can see, the Immut-powered reducer is a lot more readable, and was a lot simpler to write. Ultimately, both of these reducers are doing the same thing. They're shallow copying any table you intend to modify, and adding new data to those tables. With the RoduxUtils version of createReducer, your handlers are automatically wrapped with Immut.produce, so you don't need to worry about including it yourself. The rest of the examples on this page will be using the RoduxUtils version. We'll refer to this version as an &quot;Immut reducer&quot; to keep it simple. tip From this point onwards, this article will use the callback notation ofRoduxUtils.createReducer when creating a reducer. Read theAPI section on createReducer for more info. "},{"title":"Returning​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#returning","content":""},{"title":"A value​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#a-value","content":"When returning a value from an Immut reducer, the returned value will be used as the result rather than the draft. This is useful when we're doing something like discarding the whole state and replacing it with a new one. local reducer = RoduxUtils.createReducer(function(builder) builder:addCase(&quot;stateReset&quot;, function(state, action) return {} -- sets state to {} end) end)  "},{"title":"nil​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#nil","content":"Returning nil from an Immut reducer is the same as returning state. All three of the following handlers will have the same result. local reducer = RoduxUtils.createReducer(function(builder) builder :addCase(&quot;returnState&quot;, function(state, action) state.value += 1 return state end) :addCase(&quot;returnNil&quot;, function(state, action) state.value += 1 return nil end) :addCase(&quot;noReturn&quot;, function(state, action) state.value += 1 end) end)  "},{"title":"Using the table library​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#using-the-table-library","content":"Unfortunately, Lua's (and by extension, Luau's) builtin table library does not work as expected with drafts. To get around this, Immut comes with replacements for table.remove and table.insert. They are exposed from RoduxUtils asDraft.remove and Draft.insert. "},{"title":"Opting out​","type":1,"pageTitle":"Dealing with Immutable data","url":"/rodux-utils/docs/solutions/immut#opting-out","content":"None of this is to say that Immut is always better. There may be cases where you find that being explicit is better. In that case, you may opt to write your reducer manually. You should always try to use the best tool for the job! Opting out of Immut for certain handlers is easy. Just call Draft.original on the draft state passed into your handler to get the original table. You can then proceeed as you would normally. local inventoryReducer = RoduxUtils.createReducer(function(builder) builder:addCase(&quot;itemRemoved&quot;, function(draft, action) local state = Draft.original(draft) local newState = table.clone(state) -- we can now write our reducer without Immut return newState end) end) })  You can do this at any point in your handler. It doesn't need to be from the start. "},{"title":"Deriving data from State","type":0,"sectionRef":"#","url":"/rodux-utils/docs/solutions/selectors","content":"","keywords":""},{"title":"Selectors​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#selectors","content":"Selectors are functions that encapsulate the logic for deriving data from state. They allow you to keep your state minimal by shifting the burden of calculating more complicated data to the consumer of the state. We'll use this pattern in the following example to filter some data. Our state contains a list of all of the players ingame right now. We're going to create a filter that only returns players who are on the blue team. Here's what our state looks like: local state = { players = { { username = &quot;Alex&quot;, team = &quot;green&quot; }, { username = &quot;Ben&quot;, team = &quot;red&quot; }, { username = &quot;Matt&quot;, team = &quot;blue&quot; }, } }  And here's how we'll filter it with a selector: local function selectBlueTeam(state) local blueTeam = {} for _, player in state.players do if player.team == &quot;blue&quot; then table.insert(blueTeam, player) end end return blueTeam end  Now we can get all of the Blue team's players from our state when it changes. -- A Roact component somewhere... local function blueTeamList(props) local blueTeam = useSelector(selectBlueTeam) ... end  As you can see, this made it pretty easy to get exactly what we were looking for without having to split our state up to accomodate the team feature of our game. We don't need a reducer for teams, we can just derive team data from our existing players reducer. There is a problem with this implementation, though. Every time the store updates, we're going to call that selectBlueTeam selector. It might not be that bad with only four players, but as the size of the server expands, that filter is going to become slower. It would be nice if we could only run the selector when we needed to. "},{"title":"Memoization & createSelector​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#memoization--createselector","content":""},{"title":"The basics​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#the-basics","content":"Memoization is a technique that prevents calling a pure function when the result would be the same as the last time it was called. It does this by caching the result of the function and the arguments passed to it. Since a selector is a pure function, we can memoize it! RoduxUtils includes a helper for creating memoized selectors named createSelector. Let's rewrite our selectBlueTeam selector using createSelector. local function selectPlayers(state) return state.players end local selectBlueTeam = createSelector({ selectPlayers }, function(players) local blueTeam = {} for _, player in players do if player.team == &quot;blue&quot; then table.insert(blueTeam, player) end end return blueTeam end)  There's a lot to unpack here! Let's start with the selectPlayers function. It's another selector, but it's very simple. Even simpler than our originalselectBlueTeam selector. So, what's its purpose here? selectPlayers is an input selector. Under the hood, createSelector is passing the result of selectPlayers to our result function, which, in this case, is the function responsible for actually filtering the players. Since our state is immutable, that means if nothing instate.players has changed, it's going to be the same value that was passed to our result function before. That's where memoization kicks in! Since createSelector memoizes the result function for us, it won't run it again unless state.players has changed. "},{"title":"Passing arguments​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#passing-arguments","content":"The usefulness of createSelector doesn't end there, though. You can also use it to create selectors that are capable of taking more arguments than juststate. Our selectBlueTeam selector would be a lot more useful if it could select any team we wanted, wouldn't it? Let's rewrite it again with that in mind. local function selectPlayers(state) return state.players end local function selectTeamName(state, teamName) return teamName end local selectTeam = createSelector({ selectPlayers, selectTeamName, }, function(players, teamName) local team = {} for _, player in players do if player.team == teamName then table.insert(team, player) end end return team end)  That'll work, but how do we use it? Where is the teamName argument coming from? When you call a selector created with createSelector, it can take as many arguments as you'd like. The first argument should always be your state. To use this selector, we'd call it like so:  selectTeam(state, &quot;red&quot;)  "},{"title":"Custom memoization settings​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#custom-memoization-settings","content":""},{"title":"Increasing the cache size​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#increasing-the-cache-size","content":"By default, createSelector will only cache the last result. You can tweak this to your liking by passing in an additional configuration argument. local selectTeam = createSelector({ selectPlayers }, function(players) ... end, { -- set the cache size to 3 maxSize = 3, })  Now we'll cache the last 3 results of our result function. The included memoization function uses an LRU cache when the size is greater than 1. "},{"title":"Reducing recomputations with custom equality checks​","type":1,"pageTitle":"Deriving data from State","url":"/rodux-utils/docs/solutions/selectors#reducing-recomputations-with-custom-equality-checks","content":"You can change the function used to check for equality between old and new arguments that are passed to your selector. This might be useful when the result of one of your input selectors has some nested values that you want to pay extra attention to. For our example, let's take our selectors for the red and blue team and use them as our inputs. With them, we'll create a new purple team. Since our red and blue team selectors return a new table every time we run them, we will have to check the contents of each table to be sure that they're actually different. Otherwise, our result function will run every time the players in our state change, even if they aren't relevant to the purple team! local inputSelectors = { selectRedTeam, selectBlueTeam } local selectPurpleTeam = createSelector(inputSelectors, function(red, blue) local purpleTeam = {} for _, player in red do table.insert(purpleTeam, player) end for _, player in blue do table.insert(purpleTeam, player) end return purpleTeam end, { -- returns true if red &amp; blue team's players are the same as they were -- the last time the function was called equalityFn = shallowEquals, })  Nice! We've created a new team just by deriving data from what's available in our state. It doesn't end there! There's actually another way to solve this problem. We can use resultEqualityFn to check the equality of a result. Remember how we had to use a custom equalityFn because our selectors were returning a new table every time? We can avoid that problem entirely this way. We'll only refactor selectBlueTeam for now. local function selectPlayers(state) return state.players end local selectBlueTeam = createSelector({ selectPlayers }, function(players) local blueTeam = {} for _, player in players do if player.team == &quot;blue&quot; then table.insert(blueTeam, player) end end return blueTeam end, { resultEqualityFn = shallowEquals, })  That's all it needed! Now, when all of the players on the blue team are the same as they were before, the selector will return the old table instead of a new one. This can help with avoiding unnecessary reconciliation in a Roact component, or prevent another selector that uses this one as an input from running again. Like our selectPurpleTeam selector! If you made this change to the selectRedTeam selector as well, you'll have solved the problem that required us to use a shallow comparison for the arguments passed to the selectPurpleTeam selector. Neat! "},{"title":"Organizing your Rodux code","type":0,"sectionRef":"#","url":"/rodux-utils/docs/solutions/slices","content":"","keywords":""},{"title":"Slices​","type":1,"pageTitle":"Organizing your Rodux code","url":"/rodux-utils/docs/solutions/slices#slices","content":"Slices help you put all of your related Rodux code in the same spot. RoduxUtils comes with a helper function for quickly generating a slice calledcreateSlice. Let's create a slice with it now. Our slice will contain some data pertaining to the player. We'll track how much money they have, which items they own, and log any transactions made here. For now, we'll only make our reducer handle incrementing the player's money value. tip createSlice uses createReducer internally, meaning slice reducers are wrapped in an Immut producer. return createSlice({ name = &quot;playerData&quot;, initialState = { money = 0, items = {}, transactions = {}, }, reducers = { moneyIncremented = function(state, action) state.money += action.payload end, } })  Nice! We've set up our first slice. Right now it's pretty simple. Let's take a closer look at it. If we were to print the contents of our slice, it'd look something like this: { name = &quot;playerData&quot;, initialState = { money = 0, items = {}, transactions = {}, }, reducer = function, actions = { moneyIncremented = function, }, }  It looks like createSlice is reusing our name and initialState inputs, but it's done something with reducers. Not only did it create a reducer function for us, it generated some action creators too! If we plugged this reducer into our store, we can use it right away. local store = Rodux.Store.new(playerData.reducer) -- give the player $100! store:dispatch(playerData.actions.moneyIncremented(100))  "},{"title":"Customizing generated action handlers​","type":1,"pageTitle":"Organizing your Rodux code","url":"/rodux-utils/docs/solutions/slices#customizing-generated-action-handlers","content":"So far so good. We've got a working Rodux store and all of the code for it is organized neatly within our slice. Let's add some more functionality. We'll create the handlers for adding and removing items from the player's inventory. Our items are going to be very simple. They'll consist of a numeric ID, a name, and a value (in money). Since creating an item is a little more complicated than incrementing currency, we might want to make our action handler a bit easier to use. Even though our action handlers are automatically generated by createSlice, we still retain control over them. return createSlice({ name = &quot;playerData&quot;, initialState = { money = 0, items = {}, transactions = {}, }, reducers = { moneyIncremented = function(state, action) state.money += action.payload end, itemRemoved = function(state, action) state.items[action.payload] = nil end, itemAdded = { prepare = function(name, value, id) return { payload = { name = name, value = value, id = id, }, } end, reducer = function(state, action) state.items[action.payload.id] = action.payload end, }, }, })  As you can see, our itemAdded handler has a bit more going on than the others. That's because we're specifying what our action creator should look like with the prepare function. When we want to dispatch itemAdded, we can do it like this: store:dispatch(itemAdded(&quot;Name&quot;, 100, 1))  "},{"title":"Using extraReducers to add matchers and extra cases​","type":1,"pageTitle":"Organizing your Rodux code","url":"/rodux-utils/docs/solutions/slices#using-extrareducers-to-add-matchers-and-extra-cases","content":"We're almost done. The final piece is logging transactions. We're going to log all of the transactions the player has made. There is a problem, though. Multiple different action types in our game could be considered transactions. Players purchasing items, trading items, and selling items are all transactions that we want to be able to support. For simplicity, we'll make some assumptions about what a &quot;transaction&quot; actually is in our game. Every transaction can be represented by an action that has a &quot;transactionId&quot; property inside of the &quot;meta&quot; field of an action. With that in mind, we can use a matcher to handle this for us instead of adding a case for every possible transaction. We'll also adjust our existing handlers to support this format. return createSlice({ name = &quot;playerData&quot;, initialState = { money = 0, items = {}, transactions = {}, }, reducers = { moneyIncremented = function(state, action) state.money += action.payload end, itemRemoved = function(state, action) state.items[action.payload] = nil end, itemAdded = { prepare = function(name, value, id, guid) return { payload = { name = name, value = value, id = id, }, meta = { id = guid, } } end, reducer = function(state, action) state.items[action.payload.id] = action.payload end, }, }, extraReducers = function(builder) builder :addMatcher(function(action) return action.meta.transactionId ~= nil end, function(state, action) state.transactions[action.meta.transactionId] = action.payload end) end, })  That was easy! We used extraReducers to add a matcher to our slice's reducer with a ReducerBuilder Now any time an action is dispatched to our store, regardless of whether or not we've got a case reducer set up for it. "},{"title":"Combining slice reducers​","type":1,"pageTitle":"Organizing your Rodux code","url":"/rodux-utils/docs/solutions/slices#combining-slice-reducers","content":"If you put all of your slices in the same spot, you can easily require them all and combine their reducers before passing them into your store. local Slices = ReplicatedStorage.Client.Slices local reducers = {} for _, module in Slices:GetChildren() do if module:IsA(&quot;ModuleScript&quot;) then local slice = require(module) reducers[slice.name] = slice.reducer end end local reducer = Rodux.combineReducers(reducers) local store = Rodux.Store.new(reducer)  "}]